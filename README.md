ㅇmake란 무엇인가(make)
[make유틸리티는 여러 파일 중에서 수정된 소스 파일만 찾아서 재컴파일하는 과정을 자동화한다]
[소스파일 바뀐 것만 콕 집어서 재컴파일하고 링킹하는 make는 상대적으로 빠르고 편하다]
[특히 작성자가 아닌 다른 사람이 컴파일하는 경우 적절한 커맨드라인 옵션을 작성하는 과정은 매우 어렵다]
[make유틸리티와 Makerfile이 있다면 코드 작성자가 아니라 해도 컴파일을 손쉽게 할 수 있다]
[make는 Makefile을 읽고 프로그램을 어떻게 컴파일할 것인지 구체적인 정보를 찾는다]
[make의 목적파일(생성되는 바이너리 파일)은 작성한 프로그램 전체를 포함한다]
[컴파일 요청을 받은 make는 파일을 비교하면서, 각 파일이 최신인지 먼저 확인한다]
[make는 명시된 디펜던시를 토대로 빌드하돼, 파일에 바뀐 게 없는 경우 아무 작업도 하지 않는다]
[이렇게 콕 집어서 재컴파일이 가능한 건 이미 컴파일된 *.o 다른 파일이 유지되며, 재사용할 수 있기 때문이다]

ㅇmake의 고급 옵션들(Fancier make Options)
[Makefile은 make작업의 인풋(입력값)으로 사용된다]
[Makefile은 재료파일(prerequisites)를 토대로 어떤 방법으로 목적파일을 만들어낼 것인지 명세한다]
[첫번째 룰, 목적파일(target): 필요한 파일들 순서로 적는다]
[두번째 룰, 그다음 행에는 필요한 파일들에서 목적파일을 재빌드하는데 필요한 명령어를 나열한다]
[줄바꿈 행에 등장한 명령어는 꼭 탭키를 사용해서 들여써야한다. 스페이스바 4칸쓰기 하면 안된다]
[메인 목적파일 만들 때 재료파일(*.o)이 들어간 경우 해당 재료파일을 컴파일하는 방법도 써줘야한다]
[목적파일이 재료파일 oneFile.o를 포함한다면 이를 위해 oneFile.o를 생성하는 명령어를 작성해 넣어야한다]

ㅇMakefile에서 변수 사용하기(Variables)
[컴파일러 옵션으로 변수를 사용할 수 있다. CFLAGS=gcc ~... 복붙작업은 귀찮기 때문이다.]
[Makefile에선 컴파일 명령어(컴파일 플래그)를 변수처럼 선언할 수 있다]
[Makefile에 변수를 선언한 경우, 변수를 갖다 쓰는 것은 $(변수) 로 한다]

ㅇ컴파일 결과물, 부산물을 삭제하는 Clean
[타켓을 클린한다는 것은 클린파일을 만든다는 게 아니다. 컴파일된 프로그램과 오브젝트파일, 데이터백업, 기타 어수선한 파일들을 다 삭제하는 작업이다]
[클린은 디렉토리를 청소하기 위해, 전체 프로그램을 재빌드 시키기위한 준비작업 혹은 소스파일만 남기고 지우기 위해 사용한다]
[.PHONY: clean로 clean을 선언한다 .PHONY옵션은 clean파일을 생성하거나 최신인지 확인하지 않는다.
[clean은 준비물(재료파일)을 작성할 필요가 없다. 바로 rm명령어만 적으면 된다]
[일반적으로 Makefile에 클린 부분을 추가해두는게 좋다]
[made depend명령어를 커맨드창에 입력하면 Makefile에 depend: 단락이 생기고 디펜던시 기록이 된다]
[컴파일 시 -Wall -Wsign-compare -Wwrite-strings -Wtype-limits -Werror 컴파일 옵션을 권장한다]
[추가로 -fsanitize=address 옵션은 런타임을 추가적으로 체크할 수 있어 권장한다]
